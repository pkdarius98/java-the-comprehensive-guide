<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
                    
        <head><meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
            <meta content="application/xhtml+xml; charset=utf-8" name="content-type"/>
            <meta content="&#10;        &#10;    Java Platform Module System" name="title"/>
            <meta content="Christian Ullenboom" name="author"/>
            <meta content="Rheinwerk Publishing" name="publisher"/>
            <meta content="© 2023 by Rheinwerk Publishing Inc., Boston (MA)" name="copyright"/>
            <meta content="Java - The Comprehensive Guide - &#10;        &#10;    Java Platform Module System" name="description"/>
            <meta content="en" name="language"/>
            <title>
        
    Java Platform Module System</title>
            <link href="common/main.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000030211834" name="Adept.expected.resource"/>
        </head>
    


                    <body class="office_us type_">
                        <div id="main">
        
        <h2 class="t2" id="h15.4">15.4    Further Reading</h2>
        
        <p class="standard">To learn more about the history of the modules, good insights are available in various presentations by the Java’s creators at <span class="url"><a href="https://openjdk.java.net/projects/jigsaw/">https://openjdk.java.net/projects/jigsaw/</a></span>. The module system provides even more options, such as opening for reflection or transitive dependencies with 
            <samp class="listingcharacter listingcharacter">requires transitive</samp>, so that a module co-determines another module for the user. Furthermore, 
            <samp class="listingcharacter listingcharacter">provide ... with</samp> and the 
            <samp class="listingcharacter listingcharacter">uses</samp> syntax is available for service loaders. If you have an interface 
            <samp class="listingcharacter listingcharacter">I</samp> and an implementation 
            <samp class="listingcharacter listingcharacter">C</samp>, you can specify that the module information 
            <samp class="listingcharacter listingcharacter">provides I with C</samp>, while the service loader can supply the type 
            <samp class="listingcharacter listingcharacter">C</samp> with 
            <samp class="listingcharacter listingcharacter">ServiceLoader.load(I.class)</samp>. This approach works without the 
            <span class="italic">META-INF/services files</span>
         that were necessary prior to Java 9. In addition, JDK modules can be replaced by other modules, and classes can be “patched” by assigning them to other modules.</p>
        
        <p class="standard">Even though the new module system is interesting, criticism stems from the fact it doesn’t go far enough for some teams. One point of criticism is the version number, which currently is only ornamental. In general, little demand for the version number exists, and the more acerbic critics claim that the module system only exists because Oracle itself wanted to improve the modularization of its own JDK.</p>
        
        <p class="standard">A few special books describe the topic in detail, such as 
            <span class="italic">Java 9 Modularity: Patterns and Practices for Developing Maintainable Applications</span>
         by Sander Mak and Paul Bakker (O’Reilly Media, 2017).</p>
    
    </div><p class="signatur"/>
                    </body>
                </html>