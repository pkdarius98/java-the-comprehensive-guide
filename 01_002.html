<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
                    
        <head><meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
            <meta content="application/xhtml+xml; charset=utf-8" name="content-type"/>
            <meta content="&#10;        &#10;    Introduction" name="title"/>
            <meta content="Christian Ullenboom" name="author"/>
            <meta content="Rheinwerk Publishing" name="publisher"/>
            <meta content="© 2023 by Rheinwerk Publishing Inc., Boston (MA)" name="copyright"/>
            <meta content="Java - The Comprehensive Guide - &#10;        &#10;    Introduction" name="description"/>
            <meta content="en" name="language"/>
            <title>
        
    Introduction</title>
            <link href="common/main.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000030211834" name="Adept.expected.resource"/>
        </head>
    


                    <body class="office_us type_">
                        <div id="main">
        
        <h2 class="t2" id="h1.2">1.2    On the Popularity of Java: The Key Features</h2>
        
        <p class="standard">Java is an OOP language characterized by several key features to make it universally applicable and interesting for companies as a robust programming language. Because Java enables OOP, developers can create modern and reusable software components.</p>
        
        <p class="standard">In part, Java seems rather conservative, but that’s because the designers of the Java language don’t immediately incorporate everything that’s hip at the moment. Java has always incorporated into the language core what had proven useful and good in other programming languages. However, Sun and later Oracle avoided including things in the language that were only used by a few programmers or that led to frequent errors. 
            <a id="p46"/>
        In the early days, C++ stood as a role model, but today, Java is squinting at C# and scripting languages.</p>
        
        <p class="standard">Let’s now look at some central properties of Java and highlight a few key terms and modes of operation.</p>
        
        
            
            <h3 class="t3" id="h1.2.1">1.2.1    Bytecode</h3>
            
            <p class="standard">First, Java is a programming language like any other. But unlike conventional interpreters of a programming language, which usually generate machine code for a specific processor (for example, for x86 microprocessors or processors of the ARM architecture) and a specific platform (such as Linux or Windows), the Java compiler generates what’s called 
                <span class="italic">bytecode</span> from its source code files. This program code is binary and serves as the starting point for the
                <a class="indexanchor" id="i01_30"/> virtual machine (VM) to run. Bytecode
                <a class="indexanchor" id="i01_31"/>
             is comparable to microprocessor code for an imaginary processor, which knows statements like arithmetic operations, jumps, and more.</p>
        
        
        
        
            
            <h3 class="t3" id="h1.2.2">1.2.2    Executing the Bytecode via a Virtual Machine</h3>
            
            <p class="standard">For the program code of the virtual processor to be executed, a 
                <a class="indexanchor" id="i01_32"/>
                <span class="italic">runtime environment  </span>called
                <span class="italic"> </span>the 
                <a class="indexanchor" id="i01_33"/>
                <span class="italic">Java virtual machine  (JVM)</span>, takes care of the bytecode after the program code is translated into bytecode.
                <span class="footnote_anchor"><a href="footnotes.html#ftn-fn01_03" id="fn01_03">[ 3 ]</a></span> The runtime environment (also called the 
                <span class="italic">runtime interpreter</span>
                <a class="indexanchor" id="i01_34"/>) loads the bytecode, checks it, and executes it in a controlled environment. The JVM provides an entire range of additional services, such as an automatic 
                <span class="italic">garbage collector</span>
             that cleans up memory, and strong type checking under a well-defined memory and threading model.</p>
        
        
        
        
            
            <h3 class="t3" id="h1.2.3">1.2.3    Platform Independence</h3>
            
            <p class="standard">A central characteristic of Java is its 
                <span class="italic">platform independence</span>
                <a class="indexanchor" id="i01_35"/> or 
                <span class="italic">operating system independence</span>
                <a class="indexanchor" id="i01_36"/>
            . This flexibility is achieved through two key concepts: First, Java doesn’t bind itself to a particular processor or architecture; instead, the compiler generates bytecode that a runtime environment then processes. Second, Java abstracts from the properties of a concrete operating system and creates, for example, an interface to the input/output system or an application programming interface (API) for GUIs. Developers always program against a Java API, but never against the API of the actual platform, such as the Windows or Unix API. The Java Runtime Environment maps calls to files for the respective system, for example, and is thus an intermediary between the Java programs and the actual operating system API.</p>
            
            <p class="standard">
                <a id="p47"/>
            Platform-independent programming languages and runtime environments are standard today, and Java is no longer an exception. The top languages today are JavaScript, Python, Ruby, PHP, Kotlin, and C#, and all of them have a runtime environment, while some languages can also be compiled into native code. Platform independence is difficult because a programming language and a bytecode-producing compiler are only one part—the bigger part is the runtime environment and an extensive API. While C itself is a portable language, and ANSI C programs can be compiled by any C compiler on any operating system with a compiler, the problem is the libraries, which don’t go beyond a few simple file operations.</p>
        
        
        
        
            
            <h3 class="t3" id="h1.2.4">1.2.4    Java as a Language, Runtime Environment, and Standard Library</h3>
            
            <p class="standard">Not only is Java a programming language; it’s also a runtime system, which Oracle wants to make clear by using the term 
                <span class="italic">Java platform</span>
            . The programming language and JVM are accompanied by a set of standard libraries for data structures, string processing, date/time processing, GUIs, input/output operations, background threads, network operations, and more. These libraries form the basis for higher-value services such as database connections and web services.</p>
        
        
        
        
            
            <h3 class="t3" id="h1.2.5">1.2.5    Object Orientation in Java</h3>
            
            <p class="standard">Java was designed as a language to make it easy to write large, bug-free applications. In C programs, statistically, an error is expected every 55 program lines. Even in large software packages (from 1 million lines of code), an error is found on average every 200 program lines, regardless of the underlying programming language. These errors must be addressed, although to date no comprehensive strategy has been found for software development on a large scale. Much work in computer science is concerned with how thousands of programmers can work together and design software over decades. This problem is not easy to solve and was heavily debated during the software crisis of the mid-1960s.</p>
            
            <p class="standard">A runtime environment eliminates many problems of a technical nature. OOP
                <a class="indexanchor" id="i01_37"/> attempts to better model the complexity of the software problem. The philosophy is that humans think in an OO way, and thus, a programming environment should reflect this human way of thinking. Just as in the real world, objects are connected and communicate in the world of software. Objects consist of 
                <span class="italic">properties</span>
                <a class="indexanchor" id="i01_38"/>, which describe things that an object “has” and “can” do. A car “has” wheels and a seat and “can” accelerate and brake. Objects are created from 
                <span class="italic">classes</span>
                <a class="indexanchor" id="i01_39"/>
            , which are descriptions for the structure of objects.</p>
            
            <p class="standard">The Java language is not completely OO
                <a class="indexanchor" id="i01_40"/>, as
                <a class="indexanchor" id="i01_41"/> Smalltalk demonstrates. Primitive data types exist for numeric numbers or Unicode characters and aren’t managed as objects. The reason for this kind of design is that, with separation, the compiler and runtime 
                <a id="p48"/>
            environment can better optimize programs. However, Microsoft’s VM for the .NET platform and other modern programming languages show that good performance is possible even without this separation.</p>
        
        
        
        
            
            <h3 class="t3" id="h1.2.6">1.2.6    Java Is Widespread and Well Known</h3>
            
            <p class="standard">Regardless of the performance of a language, in the end, only business matters count: How quickly and cheaply can the system desired by your customer be built, and how stable and amenable to changes is it? In addition, some further questions include: What literature is available on the market? What training paths are available? Where can a team get a developer or consultant in an emergency? These points aren’t necessarily front of mind for computer scientists when comparing languages, but these questions can be decisive for the success of a software platform. Almost every university teaches Java, and with Java, a job is certain. Conferences introduce new trends and create trends. This chain can’t be broken, and even if a new super language called “Bali” emerged today, years would be required to create a comparable system. Mind you: This discussion says nothing about innovation or performance—only about market saturation, but that’s what makes Java interesting for so many people.</p>
            
            <p class="standard">Today, Java is the basis of many highly successful products, many of which run on the server side, for example, Facebook, LinkedIn, Twitter, Amazon, and eBay. On the client side, Java is less common, although the game Minecraft is an exception to the rule.</p>
            
            <div class="box box_standard">
                
                <h6 class="boxheading"><span class="box_icon">[»]  </span>Java Developers Are Happy</h6>
                
                <p class="standard first last">Andrew Vos looked at the comments developers added to their programs through version control.
                    <span class="footnote_anchor"><a href="footnotes.html#ftn-fn01_04" id="fn01_04">[ 4 ]</a></span>
                 In doing so, he counted how many “bad” words like “omg” and “wtf” occur at check-in. His approach may not be statistically tidy, but in the projects he examined, Java developers are doing quite well and have little to swear about. The comments are amusing to read and provide different explanations, such as that JavaScript programmers really only swear about Internet Explorer, but not about the JavaScript language itself, and that Python programmers are too decent to swear.</p>
            
            </div>
        
        
        
        
            
            <h3 class="t3" id="h1.2.7">1.2.7    Java Is Fast: Optimization and Just-In-Time Compilation</h3>
            
            <p class="standard">JVM version 1.0 started with a pure interpretation of the bytecode. This approach caused massive speed problems because, during interpretation, the work of a processor—recognizing, decoding, and executing a statement—must be repeated again in software, which takes a lot of time. Java programs of the first hour were therefore significantly slower than interpreted C(++) programs and earned Java the reputation of being a slow language.</p>
            
            <p class="standard">
                <a id="p49"/>The
                <a class="indexanchor" id="i01_42"/> 
                <span class="italic">just-in-time (JIT) compiler</span> technique
                <a class="indexanchor" id="i01_43"/>
                <span class="footnote_anchor"><a href="footnotes.html#ftn-fn01_05" id="fn01_05">[ 5 ]</a></span> was a first step to addressing the problem. A JIT compiler accelerates the execution of programs by translating the bytecode (i.e., the program instructions of the VM) into the machine code for the respective platform at runtime. A translation at runtime has enormous optimization potential because the JVM naturally knows what kind of CPU is used and can generate the best possible machine code for that CPU. One example is the instruction set extension called 
                <span class="italic">Streaming SIMD Extensions 2 (SSE2)</span>
             for x86 processors: If the JVM finds this processor type, SSE2 code can be generated; otherwise, not.</p>
            
            <p class="standard">After translation, a program is available in the memory adapted to the architecture, which the physical processor executes quickly without interpretation. With this technique, the speed is equal to that of other translated languages. However, a good JIT doesn’t translate everything; instead, the compiler uses various heuristics to determine whether a translation—which itself takes time—is worthwhile at all. The JVM therefore always starts with an interpretation and then switches to compiler mode when necessary. Thus, Java is basically a compiled language, but also an interpreted programming language—apart from the execution via hardware. The Java compiler in the JVM might be the most frequently run compiler overall. And the result is exceptionally good, as can be seen when comparing Java to other languages.</p>
            
            <p class="standard">Sun’s JIT compiler continued to improve and evolve into a family of VMs now known as 
                <span class="italic">HotSpot</span>
                <a class="indexanchor" id="i01_44"/>. One special feature is that HotSpot monitors execution at runtime and finds “hot” (i.e., critical) spots, such as loops with many repetitions. The JVM can then control translations and optimizations in a targeted manner. Optimizations include classics such as expression merging, but also many dynamic optimizations fall into this area that a static C++ compiler wouldn’t understand because it lacks context.
                <span class="footnote_anchor"><a href="footnotes.html#ftn-fn01_06" id="fn01_06">[ 6 ]</a></span>
             In addition, the JVM can reload bytecode at any time, which is optimized in the same way since all parts that have been previously loaded. The newly introduced program code can even invalidate old optimizations and machine code, which the JVM then recompiles.</p>
            
            <div class="imagebox figure-type"><a href="img-f1.3.html" id="f1.3"><img alt="The Traditional Compiler and the Java Compiler with the Runtime Environment" id="img-f1.3" src="bilderklein/klein01_003.png"/></a></div>
            
            <p class="caption "><b>Figure 1.3</b>    
            The Traditional Compiler and the Java Compiler with the Runtime Environment</p>
            
            <p class="standard">
                <a id="p50"/>HotSpot, just like the runtime system, is published under the free GNU General Public License (GPL) license and can be viewed by everyone. The JVM is mainly programmed in C++, but for performance reasons, some parts are in machine code, which makes porting not so easy. The 
                <span class="italic">Zero-Assembler Project</span>
                <a class="indexanchor" id="i01_45"/> (<span class="url"><a href="https://openjdk.java.net/projects/zero">https://openjdk.java.net/projects/zero</a></span>) aims to realize HotSpot without machine code, so that porting is easy. The HotSpot VM has its own development and version numbers.</p>
            
            <p class="standard">Completely new options are available with solutions like 
                <span class="italic">GraalVM</span>
                <a class="indexanchor" id="i01_46"/> (<span class="url"><a href="https://www.graalvm.org">https://www.graalvm.org</a></span>), which can mix JavaScript, Ruby, R, and Python in addition to Java. GraalVM can also compile native executables since the path via a classic runtime environment is no longer necessary.</p>
        
        
        
        
            
            <h3 class="t3" id="h1.2.8">1.2.8    Pointers and References</h3>
            
            <p class="standard">In Java, no pointers
                <a class="indexanchor" id="i01_47"/>
                <a class="indexanchor" id="i01_48"/> to memory areas exist, as they are known and feared from other programming languages. However, since an OOP language can’t function without references, Java introduced 
                <span class="italic">references</span>. A reference represents an object, and a variable stores this reference (called a 
                <span class="italic">reference variable</span>
                <a class="indexanchor" id="i01_49"/>). While programmers work only with references, the JVM associates the reference with a memory area; the access, called 
                <span class="italic">dereferencing</span>
                <a class="indexanchor" id="i01_50"/>
            , is indirect. References and memory blocks are therefore separated, which is quite flexible because Java can move an object in memory.</p>
            
            <p class="standard">The object built in memory has a type that can’t change, which is called the 
                <span class="italic">object type</span>
                <a class="indexanchor" id="i01_51"/>: A car remains a car and is not a laminating system. A reference in Java can take different types; we call this a 
                <span class="italic">reference type</span>
                <a class="indexanchor" id="i01_52"/>
            . For instance, a Java program can also view a car as a means of transportation.</p>
            
            <div class="box box_standard">
                
                <h6 class="boxheading"><span class="box_icon">[eg]  </span>Example*</h6>
                
                <p class="standard first">The following program shows that tinkering is possible and easy in C++, and you can access private elements via pointer arithmetic.
                    <span class="footnote_anchor"><a href="footnotes.html#ftn-fn01_07" id="fn01_07">[ 7 ]</a></span>
                 For our purposes, consider this cautionary tale:</p>
                
                <div class="listing " id="l_none_119"><pre>#include &lt;cstring&gt;<br/>#include &lt;iostream&gt;<br/>using namespace std;<br/><br/>class VeryUnsafe {<br/>public:<br/>  VeryUnsafe() { strcpy( password, "HaL9124f/aa" ); }<br/>private:<br/>  char password[ 100 ];<br/>};<br/>
                    <a id="p51"/>int main() {<br/>  VeryUnsafe badguy;<br/>  char *pass = reinterpret_cast&lt;char*&gt;( &amp; badguy );<br/>  cout &lt;&lt; "Password: " &lt;&lt; pass &lt;&lt; endl;<br/>}</pre></div>
                
                <p class="standard last">This example demonstrates how problematic the use of pointers can be. The 
                    <samp class="listingcharacter listingcharacter">badguy</samp> pointer, which was initially intended as a reference to the 
                    <samp class="listingcharacter listingcharacter">VeryUnsafe</samp> class, mutates into a 
                    <samp class="listingcharacter listingcharacter">char</samp> pointer 
                    <samp class="listingcharacter listingcharacter">pass</samp>
                 through the explicit type conversion. The characters can be read from the memory byte by byte without any problem, which also allows indirect access to the private data.</p>
            
            </div>
            
            <p class="standard">In Java, you cannot access arbitrary parts of the memory. Also, private variables are safe for now.
                <span class="footnote_anchor"><a href="footnotes.html#ftn-fn01_08" id="fn01_08">[ 8 ]</a></span>
             The compiler aborts with an error message—or the runtime system throws an exception—if the program tries to access a private variable.</p>
        
        
        
        
            
            <h3 class="t3" id="h1.2.9">1.2.9    Take Out the Trash, Garbage Collector!</h3>
            
            <p class="standard">In programming languages such as C(++), about half of the errors can be traced back to incorrect memory allocation. Working with objects and structures inevitably means creating and deleting them. However, the JVM independently takes care of managing these objects. As a result, objects don’t need to be released; Java’s 
                <span class="italic">garbage collector </span>
                <a class="indexanchor" id="i01_53"/>
                <a class="indexanchor" id="i01_54"/>removes them. After explicitly building an object, Java’s runtime system permanently monitors whether the object is still needed (i.e., still referenced). Conversely, garbage collecting also means that, if a secret reference still exists on an object, the garbage collector can’t delete the object. Note that these 
                <span class="italic">dangling references</span>
             are a nuisance and might only be found through longer debugging sessions.</p>
            
            <p class="standard">The garbage collector is a concurrent thread in the background that finds and marks unreferenced objects and removes them from time to time. Thus, the garbage collector eliminates the need for manual memory queries. We should welcome this technology because many problems can disappear, such as memory leaks, where the release is “forgotten” and the utilized memory keeps swelling.</p>
            
            <p class="standard">Automatic garbage collection is not without problems, since garbage collecting can strike whenever the system wants to do something time-critical, and interruptions aren’t convenient. However, modern garbage collectors are good at detecting few active cycles and distributing the work evenly and also over several processor cores. But automatic garbage collection is nothing new, and these procedures have long been tried and tested. Even early programming languages such as LISP (1958) and Smalltalk (1972) included a garbage collector, and all modern programming languages (or their runtime environments) have automatic garbage collection.</p>
        
        
        
        
            
            <h3 class="t3" id="h1.2.10">1.2.10    
                <a id="p52"/>
            Exception Handling</h3>
            
            <p class="standard">Not everything can be planned. Sometimes, a network connection breaks down; sometimes, a file disappears; and sometimes, the divisor of an integer division process is 0. Java provides 
                <span class="italic">exceptions</span>
                <a class="indexanchor" id="i01_55"/>
             to deal with runtime errors. Exceptions are error objects that are generated at runtime to indicate an error and to interrupt the general flow of the program. These problem areas can be encapsulated by program constructs. The solution in many cases is cleaner than using return values and unreadable expressions in the program flow.</p>
            
            <p class="standard">For speed reasons, C(++)
                <span class="footnote_anchor"><a href="footnotes.html#ftn-fn01_09" id="fn01_09">[ 9 ]</a></span> doesn’t check the
                <a class="indexanchor" id="i01_56"/> bounds of an array via 
                <a class="indexanchor" id="i01_57"/>
                <span class="italic">range checking</span> by default, which can cause many security problems. Incorrect access to the element 
                <samp class="listingcharacter listingcharacter">n + 1</samp> of an array of size 
                <samp class="listingcharacter listingcharacter">n</samp>
             can cause two things: An access error occurs, or—much worse—other data is overridden during write access, and the error is no longer traceable.</p>
            
            <p class="standard">Java’s runtime system automatically checks the bounds of an array. These monitors can’t be switched off, as the compilers of other programming languages sometimes allow. A clever runtime environment finds out whether no overrun is possible and then optimizes this query away; array checks are therefore no longer costly and don’t automatically make themselves felt through poorer performance.</p>
        
        
        
        
            
            <h3 class="t3" id="h1.2.11">1.2.11    The Range of Libraries and Tools</h3>
            
            <p class="standard">Java has been around for so long now that there’s a large number of tools, from development environments with supporting editors to good debuggers and build management tools. In addition to the standard libraries, other commercial or open-source libraries can be added. Whether writing PDF documents, reading Microsoft Excel documents, transferring data to SAP, or controlling the cash ejection at an ATM—Java libraries exist for all of these capabilities.</p>
            
            <div class="imagebox figure-type"><a href="img-f_none_01_03.html" id="f_none_01_03"><img alt="" id="img-f_none_01_03" src="bilderklein/klein01_003_01.png"/></a></div>
            
            <p class="standard">
                <a id="p53"/>
            New programming languages have a hard time keeping up. The number of programming languages has exploded in recent years, but they can’t really attract the masses because they lack tools and libraries. More interesting are new languages based on the JVM because these programming languages still allow the use of the known tools and established libraries.</p>
            
            <p class="standard">However, tools and libraries are sometimes what keep teams from switching to Java. Especially in game development, teams may have a lot of experience in C(++) and have spent years putting energy into gaming frameworks—the tools are simply there, but in Java, they aren’t available (yet).</p>
        
        
        
        
            
            <h3 class="t3" id="h1.2.12">1.2.12    Comparably Simple Syntax</h3>
            
            <p class="standard">The syntax of Java is rather simple compared to languages like C++ or Perl and doesn’t bristle with operators or complexity. Java inherited a simple and basic syntax from C, like the curly brackets, but avoided overloading the syntax with all sorts of things. Since programs are read more often than they’re written, a syntax must be clear and consistent—the easier developers can see what’s happening at first glance, the better.</p>
            
            <blockquote><p>“Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live.” —John Woods</p></blockquote>
            
            <p class="standard">There’s no value to compactness in itself if programs are simply compact but the time required for a human to understand increases exponentially. The more compact the code, the longer decoding by humans will require. Even though the following Perl example from “The Fifth Obfuscated Perl Contest Results”
                <span class="footnote_anchor"><a href="footnotes.html#ftn-fn01_10" id="fn01_10">[ 10 ]</a></span>
             was deliberately designed as an unreadable program; anyone encountering at this program will get dizzy just looking at it:</p>
            
            <div class="listing " id="l_none_131"><pre>#:: ::-| ::-| .-. :||-:: 0-| .-| ::||-| .:|-. :||<br/>open(Q,$0);while(&lt;Q&gt;){if(/^#(.*)$/){for(split('-',$1)){$q=0;for(split){s/\|<br/>/:.:/xg;s/:/../g;$Q=$_?length:$_;$q+=$q?$Q:$Q*20;}print chr($q);}}}print"\n";<br/>#.: ::||-| .||-| :|||-| ::||-| ||-:: :|||-| .:| </pre></div>
            
            <p class="standard">A simpler syntax can be seen as both a curse (more typing) and a blessing (usually easier to understand). Java is rather “chatty” and in places abandons compactness. For example, in an inheritance relationship, Java is called with something like 
                <samp class="listingcharacter listingcharacter">class Rum extends Drink</samp>; in Kotlin, you would write 
                <samp class="listingcharacter listingcharacter">class Rum : Drink</samp>; in Ruby, 
                <samp class="listingcharacter listingcharacter">class Rum &lt; Drink</samp>
            .</p>
        
        
        
        
            
            <h3 class="t3" id="h1.2.13">1.2.13    Abandoning Controversial Concepts</h3>
            
            <p class="standard">Java could basically take over everything from different programming languages and be a super-language; however, the language’s designers didn’t do so and don’t want 
                <a id="p54"/>
            that. Two capabilities of C(++) that were omitted in Java will be presented as examples in the following two sections.</p>
            
            
                
                <h4 class="t4" id="h1.2.13.1">In Java, No User-Defined
                    <a class="indexanchor" id="i01_58"/>
                    <a class="indexanchor" id="i01_59"/>
                 Overloaded Operators Exist</h4>
                
                <p class="standard">When we use an operator such as the plus sign and use it to add expressions, we usually do so with known arithmetic quantities such as floats (floating point numbers) or integers. Since the same operator character is valid on different data types, such an operator is called 
                    <span class="italic">overloaded</span>. Operators like 
                    <samp class="listingcharacter listingcharacter">+</samp>, 
                    <samp class="listingcharacter listingcharacter">-</samp>, 
                    <samp class="listingcharacter listingcharacter">*</samp>, and 
                    <samp class="listingcharacter listingcharacter">/</samp> are overloaded for numbers just like the operators OR, AND, or XOR for integers and Boolean values. The comparison operators 
                    <samp class="listingcharacter listingcharacter">==</samp> and 
                    <samp class="listingcharacter listingcharacter">!=</samp> are also overloaded because they can be used with all numbers, but also with truth values or object references. A conspicuously overloaded operator is the plus sign in strings. Strings can be easily created with a plus sign. Programmers use the word 
                    <span class="italic">concatenation</span> (rarely 
                    <span class="italic">catenation</span>) in this context. For the strings 
                    <samp class="listingcharacter listingcharacter">"Hello" + " " + "you there"</samp>, 
                    <samp class="listingcharacter listingcharacter">"Hello you there"</samp>
                 is the concatenation of the strings.</p>
                
                <p class="standard">In Java, you cannot give new meanings to existing operators. Other programming languages might allow this redefinition, among them Python, C++, C#, and even ALGOL from 1968. For example, the plus sign might be used to add geometric point objects, divide fractions, or write a line to a file. If the objects represent mathematical constructs, operations named using short operator characters can be convenient—a 
                    <samp class="listingcharacter listingcharacter">matrix1.add(matrix2)</samp> with a longer method name is bulkier than a 
                    <samp class="listingcharacter listingcharacter">matrix1 + matrix2</samp>
                . Although user-defined overloaded operators are sometimes quite handy, the possibility might often provoke nonsensical uses. For this reason, the Java’s designers didn’t provide this option in Java, but some alternative languages on the JVM (e.g., Kotlin or Scala) allow it because it’s a language constraint and not a VM constraint.</p>
            
            
            
            
                
                <h4 class="t4" id="h1.2.13.2">No Preprocessor for Text Replacements Exists*</h4>
                
                <p class="standard">Many C(++) programs include preprocessor directives, such as 
                    <samp class="listingcharacter listingcharacter">#define</samp>, 
                    <samp class="listingcharacter listingcharacter">#include</samp>, or 
                    <samp class="listingcharacter listingcharacter">#if</samp>, for including prototype definitions or for conditional compilation
                    <a class="indexanchor" id="i01_60"/>
                    <a class="indexanchor" id="i01_61"/>
                    <a class="indexanchor" id="i01_62"/>. Such preprocessor directives don’t exist in Java. Without a preprocessor, a conditional compilation via 
                    <samp class="listingcharacter listingcharacter">#ifdef</samp>
                    <a class="indexanchor" id="i01_63"/> isn’t possible either. Within statement blocks, in Java, you can instead formulate conditions of the type 
                    <samp class="listingcharacter listingcharacter">if (true)</samp> or 
                    <samp class="listingcharacter listingcharacter">if (false)</samp>; using the 
                    <samp class="listingcharacter listingcharacter">-D</samp> switch on the command line, you can introduce variables that an 
                    <samp class="listingcharacter listingcharacter">if</samp> statement can then check at runtime via 
                    <samp class="listingcharacter listingcharacter">System.getProperty(...)</samp>
                .</p>
            
            
        
        
        
        
            
            <h3 class="t3" id="h1.2.14">1.2.14    Java Is Open Source</h3>
            
            <p class="standard">The source code of the standard libraries has already been available since Java 1.0 (if installed with the JDK, this source code can be found in the root directory under the name 
                <span class="italic">src.zip</span>), and anyone interested could look at the implementation. Although Sun disclosed the implementations at the time, neither the runtime environment nor the compiler or the libraries were under an accepted open-source license. Ten years after the first release of Java, there have been calls for Sun to place the entire Java platform 
                <a id="p55"/>under a more familiar type of license, such as the GPL or the Berkeley Source Distribution (BSD) license. At the same time, Jonathan Schwartz hinted at the JavaOne conference 2006 in San Francisco: “It’s not a question of whether we’ll open source Java, now the question is how.” So if the question was “how” instead of “if,” Rich Green announced the final release of Java as 
                <span class="italic">OpenJDK</span>
                <a class="indexanchor" id="i01_64"/>
                <span class="footnote_anchor"><a href="footnotes.html#ftn-fn01_11" id="fn01_11">[ 11 ]</a></span>
             under the open-source GPL 2 license during the opening speech of the JavaOne conference in May 2007. This event was preceded by the release of the compiler and VM at the end of 2006.</p>
            
            <p class="standard">You’ll find several statistics about the use of Java at <span class="url"><a href="https://www.openhub.net/p/openjdk">https://www.openhub.net/p/openjdk</a></span>, such as the following:</p>
            
            <ul>
                
                <li>
                    
                    <p class="standard first-item last-item">More than 11 million lines of code in total have been written.</p>
                
                </li>
                
                <li>
                    
                    <p class="standard first-item last-item">Over 66,000 total commits have been made to the version control system since the inception of OpenJDK.</p>
                
                </li>
                
                <li>
                    
                    <p class="standard first-item last-item">About 70% of OpenJDK is Java code, about 10% C and C++.</p>
                
                </li>
                
                <li>
                    
                    <p class="standard first-item last-item">According to the 
                        <span class="italic">Constructive Cost Model (COCOMO)</span>
                    , more than 3,600 years of development work have gone into the code.</p>
                
                </li>
            
            </ul>
            
            <p class="standard">Basically, with the OpenJDK, every developer can put together their own Java source code and publish any extensions. With the GPL license type, Java can find a place on Linux distributions that previously didn’t want to integrate Java for licensing reasons.</p>
        
        
        
        
            
            <h3 class="t3" id="h1.2.15">1.2.15    What Java Is Less Suitable for</h3>
            
            <p class="standard">Java was designed as a programming language for general problems and covers large application areas (and is thus called a 
                <span class="italic">general-purpose language</span>
            ). However, some programming languages will be clearly better for a number of use cases. One example is in the area of scripting, where the constraint that every Java program requires at least one class and one method is rather annoying. Similarly, in the area of automated text processing, other programming languages can work more elegantly with regular expressions.</p>
            
            <p class="standard">Also, when you have extremely machine- and platform-dependent requirements, things become cumbersome in Java. Java was designed to be platform-independent, so all methods should run on all systems. Extremely system-related properties, such as the clock frequency, are simply not visible, and security-relevant manipulations such as access to certain memory cells are also prohibited. </p>
            
            <p class="standard">A few things Java can’t do by default include the following:</p>
            
            <ul>
                
                <li>
                    
                    <p class="standard first-item last-item">Clearing the screen on the text console, positioning the cursor, and setting colors</p>
                
                </li>
                
                <li>
                    
                    <p class="standard first-item last-item">Accessing low-level network protocols like ICMP</p>
                
                </li>
                
                <li>
                    
                    <p class="standard first-item last-item">Automating Microsoft Office</p>
                
                </li>
                
                <li>
                    
                    <p class="standard first-item last-item">
                        <a id="p56"/>
                    Reading images from a camera</p>
                
                </li>
                
                <li>
                    
                    <p class="standard first-item last-item">Accessing USB
                        <span class="footnote_anchor"><a href="footnotes.html#ftn-fn01_12" id="fn01_12">[ 12 ]</a></span>
                     or FireWire</p>
                
                </li>
            
            </ul>
            
            <p class="standard">With the disadvantage that Java can’t access the hardware, the language can’t be easily used for system programming. Driver software that addresses graphics, sound, or network cards can only be implemented in Java via workarounds. Exactly the same limitation applies to accessing the general functions of the operating system provided by Windows, Linux, or any other system. Typical system programming languages are C(++) or Go. Furthermore, since the JVM has a certain size, Java is not an option for microcontrollers so far.</p>
            
            <p class="standard">Because of these limitations, note that Java can’t replace a hardware-oriented language. But the language doesn’t have to! Each language has its preferred terrain, and Java is a general-purpose application programming language; C(++) can still be used for hardware drivers, embedded systems, and VMs. The standard JVM is (so far still) written in C++ and is compiled using the garbage collector of the compiler or Microsoft Visual Studio Code (VS Code) and XCode. C and C++ will never disappear; these languages are like microbes in volcanic gas—they outlast all life. And just a microorganism becomes the food for other organisms, we can’t get along without system-related languages like C(++) or Go.</p>
            
            <p class="standard">If a Java program is nevertheless required to use system-related properties—which is problem free via the appropriate libraries—the 
                <span class="italic">native call</span>
                <a class="indexanchor" id="i01_65"/>
                <a class="indexanchor" id="i01_66"/>
             of a system function, for example, is a good choice. Native methods are subroutines that aren’t implemented in Java but in another programming language, often C(++). In some cases, an external program can also be called to manipulate the Windows registry or set file permissions, for example. However, ultimately, the solution must always be implemented anew for each platform.</p>
        
        
    
    </div><p class="signatur"/>
                    </body>
                </html>