<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
                    
        <head><meta content="application/xhtml+xml; charset=utf-8" http-equiv="Content-Type"/>
            <meta content="application/xhtml+xml; charset=utf-8" name="content-type"/>
            <meta content="&#10;        &#10;    Nested Types" name="title"/>
            <meta content="Christian Ullenboom" name="author"/>
            <meta content="Rheinwerk Publishing" name="publisher"/>
            <meta content="© 2023 by Rheinwerk Publishing Inc., Boston (MA)" name="copyright"/>
            <meta content="Java - The Comprehensive Guide - &#10;        &#10;    Nested Types" name="description"/>
            <meta content="en" name="language"/>
            <title>
        
    Nested Types</title>
            <link href="common/main.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:e0000000-0000-0000-0000-000030211834" name="Adept.expected.resource"/>
        </head>
    


                    <body class="office_us type_">
                        <div id="main">
        
        <h2 class="t2" id="h10.3">10.3    
            <a id="p603"/>
        Non-Static Nested Types</h2>
        
        <p class="standard">A non-static nested type is an inner type that is comparable to an object property. Let’s declare an inner class named 
            <samp class="listingcharacter listingcharacter">Room</samp> in 
            <samp class="listingcharacter listingcharacter">House</samp>
         with the following example code:</p>
        
        <div class="listing " id="l10.3"><pre><span class="">class</span><span class=""> AlmondJoy </span><span class="">{</span><span class=""><br/></span><br/>  <span class="">String</span><span class=""> name </span><span class="">=</span><span class=""> </span><span class="">"Almond Joy"</span><span class="">;</span><span class=""><br/></span>  <span class="">private</span><span class=""> </span><span class="">int</span><span class=""> introduced </span><span class="">=</span><span class=""> </span><span class="">1946</span><span class="">;</span><span class=""><br/></span><br/>  <span class="">class</span><span class=""> Coconut </span><span class="">{</span><span class=""><br/></span>    <span class="">void</span><span class=""> </span><span class="">print</span><span class="">()</span><span class=""> </span><span class="">{</span><span class=""><br/></span>      System<span class="">.</span><span class="">out</span><span class="">.</span><span class="">println</span><span class="">(</span><span class=""> name </span><span class="">);</span><span class=""><br/></span>      System<span class="">.</span><span class="">out</span><span class="">.</span><span class="">println</span><span class="">(</span><span class=""> introduced </span><span class="">);</span><span class=""><br/></span>    <span class="">}</span><span class=""><br/></span>  <span class="">}</span><span class=""><br/></span><span class="">}</span><span class=""> </span></pre></div>
        
        <p class="caption "><b>Listing 10.3</b>    
            src/main/java/com/tutego/insel/nested/AlmondJoy.java (Snippet)</p>
        
        <p class="standard">An instance of the 
            <samp class="listingcharacter listingcharacter">Coconut</samp> class has access to all members of 
            <samp class="listingcharacter listingcharacter">AlmondJoy</samp>
        , including its private members.</p>
        
        
            
            <h3 class="t3" id="h10.3.1">10.3.1    Creating Instances of Inner Classes</h3>
            
            <p class="standard">To create an instance of 
                <samp class="listingcharacter listingcharacter">Coconut</samp>, an instance of the outer class must exist first. One important difference in this regard relates to the static nested classes: Static nested types can exist even without an object of the outer class, as discussed in 
                <span class="crossreference "><a href="10_002.html#h10.2">Section 10.2</a></span>
            .</p>
            
            <p class="standard">In a constructor or in an object method of the outer class, an instance of the inner class can be created simply via the 
                <samp class="listingcharacter listingcharacter">new</samp> keyword. If you are coming from outside the outer class (or from a static block of the outer class) and you want to create instances of the inner class, for non-static nested classes, you must ensure that an instance of the outer class is available. Java prescribes a special form for the creation via 
                <samp class="listingcharacter listingcharacter">new</samp>
            , which has the following general format:</p>
            
            <div class="listing " id="l_none_10110"><pre>
                <span class="italic"><span class="">reference</span></span>.
                <span class="bold"><span class="">new</span></span><span class=""> </span><span class="">InnerClass</span><span class="">(…) </span><span class=""/></pre></div>
            
            <p class="standard">In this syntax, 
                <samp class="listingcharacter listingcharacter">reference</samp> is a reference of the type of the outer class. To create an object in the static 
                <samp class="listingcharacter listingcharacter">main(String[])</samp>
             method of the house, you can write the following code:</p>
            
            <div class="listing " id="l10.4"><pre>AlmondJoy almondJoy <span class="">=</span><span class=""> </span><span class="">new</span><span class=""> </span><span class="">AlmondJoy</span><span class="">();</span><span class=""><br/></span>Coconut coconut <span class="">=</span><span class=""> almondJoy</span><span class="">.</span><span class="">new</span><span class=""> </span><span class="">Coconut</span><span class="">();</span><span class=""> </span></pre></div>
            
            <p class="caption "><b>Listing 10.4</b>    
            src/main/java/com/tutego/insel/nested/AlmondJoy.java, main()</p>
            
            <p class="standard">
                <a id="p604"/>
            This code can even be reduced to one line:</p>
            
            <div class="listing " id="l_none_10135"><pre>Coconut coconut <span class="">=</span><span class=""> </span><span class="">new</span><span class=""> </span><span class="">AlmondJoy</span><span class="">().</span><span class="">new</span><span class=""> </span><span class="">Coconut</span><span class="">();</span><span class=""> </span></pre></div>
        
        
        
        
            
            <h3 class="t3" id="h10.3.2">10.3.2    The this Reference</h3>
            
            <p class="standard">
                <a class="indexanchor" id="i10_14"/>If an inner class 
                <samp class="listingcharacter listingcharacter">In</samp> wants to access the 
                <samp class="listingcharacter listingcharacter">this</samp> reference of its surrounding class 
                <samp class="listingcharacter listingcharacter">Out</samp>, you must write 
                <samp class="listingcharacter listingcharacter">Out.this</samp>. If variables of the inner class overlap variables of the outer class, you would write 
                <samp class="listingcharacter listingcharacter">Out.this.property</samp> to access the members of the outer class 
                <samp class="listingcharacter listingcharacter">Out</samp>
            .</p>
            
            <div class="listing " id="l10.5"><pre><span class="">class</span><span class=""> FurnishedHouse </span><span class="">{</span><span class=""><br/></span><br/>  <span class="">String</span><span class=""> s </span><span class="">=</span><span class=""> </span><span class="">"House"</span><span class="">;</span><span class=""><br/></span><br/>  <span class="">class</span><span class=""> Room </span><span class="">{</span><span class=""><br/></span>    <span class="">String</span><span class=""> s </span><span class="">=</span><span class=""> </span><span class="">"Room"</span><span class="">;</span><span class=""><br/></span><br/>    <span class="">class</span><span class=""> Chair </span><span class="">{</span><span class=""><br/></span>      <span class="">String</span><span class=""> s </span><span class="">=</span><span class=""> </span><span class="">"Chair"</span><span class="">;</span><span class=""><br/></span><br/>      <span class="">void</span><span class=""> </span><span class="">print</span><span class="">()</span><span class=""> </span><span class="">{</span><span class=""><br/></span>        System<span class="">.</span><span class="">out</span><span class="">.</span><span class="">println</span><span class="">(</span><span class=""> s </span><span class="">);</span><span class="">                     </span><span class=""> // Chair</span><span class=""><br/></span>        System<span class="">.</span><span class="">out</span><span class="">.</span><span class="">println</span><span class="">(</span><span class=""> </span>
                <span class="bold"><span class="">this</span><span class="">.s</span></span> );                <span class=""> // Chair</span><span class=""><br/></span>        System.out.<span class="">println</span><span class="">( </span>
                <span class="bold">Chair.<span class="">this</span><span class="">.s</span></span> );          <span class=""> // Chair</span><span class=""><br/></span>        System.out.<span class="">println</span><span class="">( </span>
                <span class="bold">Room.<span class="">this</span><span class="">.s</span></span> );           <span class=""> // Room</span><span class=""><br/></span>        System.out.<span class="">println</span><span class="">( </span>
                <span class="bold">FurnishedHouse.<span class="">this</span><span class="">.s</span></span> ); <span class=""> // House</span><span class=""><br/></span>      }<br/>    }<br/>  }<br/><br/>  <span class="">public</span><span class=""> </span><span class="">static</span><span class=""> </span><span class="">void</span><span class=""> </span><span class="">main</span><span class="">( </span><span class="">String</span><span class="">[] args ) {</span><br/>    <span class="">new</span><span class=""> </span><span class="">FurnishedHouse</span><span class="">().</span><span class="">new</span><span class=""> </span><span class="">Room</span><span class="">().</span><span class="">new</span><span class=""> </span><span class="">Chair</span><span class="">().</span><span class="">print</span><span class="">();</span><br/>  }<br/>} <span class=""/></pre></div>
            
            <p class="caption "><b>Listing 10.5</b>    
            src/main/java/com/tutego/insel/nested/FurnishedHouse.java, FurnishedHouse</p>
            
            <div class="box box_standard">
                
                <h6 class="boxheading"><span class="box_icon">[»]  </span>Note</h6>
                
                <p class="standard first last">Non-static nested classes can be nested arbitrarily, but since the name is unique, you can always get to the particular property via 
                    <samp class="listingcharacter listingcharacter">classname.this</samp>
                .</p>
            
            </div>
            
            <p class="standard">Considering our earlier examples, objects for the inner classes 
                <samp class="listingcharacter listingcharacter">Room</samp> and 
                <samp class="listingcharacter listingcharacter">Chair</samp>
             can be created in the following ways:</p>
            
            <div class="listing " id="l_none_10152"><pre>
                <a id="p605"/>FurnishedHouse h            <span class="">=</span><span class=""> </span><span class="">new</span><span class=""> </span><span class="">FurnishedHouse</span><span class="">();</span><span class=""> </span><span class=""> // Instance of FurnishedHouse</span><span class=""><br/></span>FurnishedHouse<span class="">.</span><span class="">Room r       </span><span class="">=</span><span class=""> h</span><span class="">.</span><span class="">new</span><span class=""> </span><span class="">Room</span><span class="">();</span><span class="">         </span><span class=""> // Instance of Room in h</span><span class=""><br/></span>FurnishedHouse<span class="">.</span><span class="">Room</span><span class="">.</span><span class="">Chair c </span><span class="">=</span><span class=""> r</span><span class="">.</span><span class="">new</span><span class=""> </span><span class="">Chair</span><span class="">();</span><span class="">        </span><span class=""> // Instance of Chair in r</span><span class=""><br/></span>c<span class="">.</span><span class="">print</span><span class="">();</span><span class="">                                          </span><span class=""> // Method of Chair</span><span class=""> </span></pre></div>
            
            <p class="standard">The qualification with the dot in 
                <samp class="listingcharacter listingcharacter">FurnishedHouse.Room.Chair</samp> doesn’t automatically mean that 
                <samp class="listingcharacter listingcharacter">FurnishedHouse</samp> is a package with the 
                <samp class="listingcharacter listingcharacter">Room</samp> subpackage in which the 
                <samp class="listingcharacter listingcharacter">Chair</samp>
             class exists. The double use of the dot doesn’t really improve readability, and you risk creating confusion between inner classes and packages. For this reason, a naming convention should be followed: Class names should start with uppercase letters; package names, with lowercase letters.</p>
        
        
        
        
            
            <h3 class="t3" id="h10.3.3">10.3.3    Class Files Generated by the Compiler*</h3>
            
            <p class="standard">For our 
                <samp class="listingcharacter listingcharacter">House</samp> and 
                <samp class="listingcharacter listingcharacter">Room</samp> example, the compiler creates the 
                <span class="italic">House.class</span> and 
                <span class="italic">House$Room.class</span> files. For the inner class to access the object variables of the outer class, the compiler automatically generates a reference to the associated object of the outer class in each instance of the inner class. As a result, the inner class can also access object variables of the outer class. For the inner class, you’ll have the 
                <span class="italic">House$Room.class</span>
             file with the following code:</p>
            
            <div class="listing " id="l_none_10149"><pre><span class="">class</span><span class=""> House$Room </span><span class="">{</span><span class=""><br/></span><br/>  <span class="">final</span><span class=""> </span>
                <span class="bold"><span class="">House </span><span class="">this</span><span class="">$</span><span class="">0</span></span><span class="">;</span><br/><br/>  
                <span class="bold">House$<span class="">Room</span><span class="">( House house )</span></span> {<br/>    <span class="">this</span><span class="">$</span><span class="">0</span><span class=""> = house;</span><br/>  }<br/>  …<br/>} <span class=""/></pre></div>
            
            <p class="standard">The 
                <samp class="listingcharacter listingcharacter">this$0</samp>
                <a class="indexanchor" id="i10_15"/> variable references the 
                <samp class="listingcharacter listingcharacter">House.this</samp> instance (i.e., the associated outer class). The constructors of the inner class get an additional parameter of type 
                <samp class="listingcharacter listingcharacter">House</samp> to initialize the 
                <samp class="listingcharacter listingcharacter">this$0 variable</samp>
            . Since you don’t get to see the constructors anyway, it’s irrelevant.</p>
        
        
    
    </div><p class="signatur"/>
                    </body>
                </html>